\section{Model checking}
\label{sec-modelcheck}

Formal methods refers to the use of precise logical and mathematical methods to reason about properties of the system \cite{Eriksson}. They contribute to the software and hardware engineering fields with formal specification and formal verification techniques, for example, aiming to increase the reliability of the system or hardware. Formal verification techniques, such as model checking, have the goal to verify the correctness, or absence of faults, of some given program code or design against its formal specifications\cite{Tian}.

Model checking is an automated technique that, given a finite-state model of a system and a formal property, systematically checks whether this property holds for that model\cite{Baier}. Typically, there is a hardware or software system specification containing the requirements, and we wish to verify that certain properties, such as nonexistence of deadlocks are valid for the model of the system. The specification is the basis for what the system should and should not do, therefore it generally is the source for the process of creating properties.

Testing and model checking have the common target of finding bugs. But as stated by Dijkstra, "program testing can at best show the presence of errors but never their absence". On the other hand, if there is a violation of a given specification, it will be found by model checking, which is supposed to be a rigorous method that exhaustively explores all possible behaviours of the system under consideration \cite{testVsModelCheck}. This is the main feature that distinguishes testing and model checking: the last one can prove the absence of bugs\cite{patrice}.

According to \cite{Baier}, the model checking process can be divided in the following phases:

\begin{itemize}

\item[1] \textbf{Modelling phase}

	Model the system under consideration using the model description language of the model checker and specify the properties to be verified using the property specification language.

\item[2] \textbf{Running}

	Run the model checker to check the validity of the properties in the system model.

\item[3] \textbf{Analysis}

In case a property was violated, then one should analyse the counter example generated by the model checker. It might be the case that the property does not truly reflect the requirement and it needs to be specified correctly. One other possible conclusion, if the property was defined appropriately, is that the model actually contains an  error and it needs improvement. Then, verification has be restarted with the improved model. But, in case the model contains no errors and it represents the system design, the violation of a property indicates that the design is incorrect and needs fixes. The verification, then, will be redone with a new model based on an improved design.
	
Otherwise, if no violation was detected, the model is concluded to posses all desired properties.

\end{itemize}

We will focus on the definition of properties in the modelling phase, since property specification is one of the goals of this project.

\subsection{Property definition}

The formal properties to be validated are mostly obtained from the system's specification\cite{Baier}. Hence, a property specifies a certain behaviour of the system that is being considered. One has to manually read through the specification and manually definy relevant properties to the system. Identifying which scenarios and behaviours should be considered when specifying properties tends to be a difficult creative process, in which human intervention becomes necessary. 

The person responsible to write the formal property specification must have a mathematical background and knowledge of the specification language \cite{Prospec}. Many model checkers such as SPIN and NuSMV accept as input properties written in Linear Temporal Logic (LTL), which is difficult to write, read and validate. Therefore, translating system requirements to formal properties is not easy.

The classic example for property definition is the absence of deadlocks, but properties can also specify safety protocols\cite{Merz}, occurrence and order of events. Let's consider, for example, that one of the requirements of a system is that always after a call to the method $open$, to open a file, there should be a call to the method $close$, to close the file. One could specify the following LTL property to verify this requirement:

\begin{center}
$\Box (open \rightarrow \Diamond close)$
\end{center}

The LTL syntax can be found in apendix \ref{ape-ltl}.

\subsection{Specification patterns}
\label{specpatterns}

The effectiveness of the assurance offered by model checking depends on the quality of the formal properties that were defined \cite{Prospec}. To assist this process, a set of property specification patterns were proposed in \cite{dwyer98}. A property specification pattern is a high-level property template that can be adapted based on the requirements to be verified. The patterns were obtained from a survey of 555 specifications collected from 35 different sources, including literature and several projects \cite{dwyer99:specpatt_survey}.

A hierarchy was established to facilitate browsing through the patterns and picking the most appropriate one to one's need. The first level of the hierarchy is composed by the occurrence and order categories described in more details in the next subsections.

For each pattern, a scope is required to define an interval of the specification in which the property should hold. The available scopes are: global, before $Q$, after $Q$, between $Q$ and $R$, after $Q$ until $R$, where $Q$ and $R$ are states or events in the specification.

\subsubsection{Occurrence patterns}

Occurrence patterns establish the occurrence or absence of a determined event or state in a certain scope of the specification. They can be further classified into:

\begin{itemize}

\item Absence: a given state or event does not occur within the scope.

\item Existence: a given state or event must occur within the scope

\item Bounded existence: a given state or event must occur $k$ times within the scope

\item Universality: a given state or event occurs throughout the scope

\end{itemize}

\subsubsection{Order patterns}

Order patterns provide descriptions for the order in which events or states occur. They are divided in categories:

\begin{itemize}
\item Precedence: a state or event $P$ should always be preceded by a state or event $Q$ within the scope

\item Response: a state or event $P$ should always be followed by a state or event $Q$ within the scope

\item Chain precedence: a sequence of states or events $P_1,...,P_n$ should always be preceded by a sequence of states or events $Q_1,...,Q_n$

\item Chain response: a sequence of states or events $P_1,...,P_n$ should always be followed by a sequence of states or events $Q_1,...,Q_n$
\end{itemize}


