\chapter{Test cases}
\label{cap:testgen}

In this section, we will be concerned with test case creation from the functional perspective. The structure of the code will not be analyzed. Instead, the specifications with the requisites are going to be the source to derive the test cases.

\input sec-testcasedesign

\input sec-autotestcases

\section{Automatic execution of test cases}

\section{Implementation of test case generation for statecharts}

In this project, we implemented the test case generation for statecharts based on the criteria described in \cite{bogdanov}. We test every transition by visiting every state and trigger events for all transitions that start in it. 

\subsection{Test case for simple statecharts}

For this section, we consider only statecharts that do not contain hierarchy and concurrency. Statecharts with hierarchy and concurrency will be explained later.


We start by making sure every reachable state in the statechart is covered. In order to do so, for each state $s$ in the statechart, we construct a path $p$ from the initial state to $s$. The path $p$ in said to be the coverage path of $s$. All coverage paths generated are stored in a set called \textit{State Cover}, which is denoted by $C$. Therefore, $C$ is a set of sequence of transition labels, such that we can find an element from this set to reach any desired state starting from the initial one \cite{bogdanov}.

Since there is no hierarchy or concurrency in the statechart, the construction of $C$ is similar to covering states of an automaton. The process can be done through a depth search:

@@@@@ ADICIONAR PSEUDO-CODIGO DA COBERTURA

Now that we have the coverage for every reachable state, we need to trigger each transition on each state and create the test cases. For each transition there will be a test case, thus every transition in the diagram will be exercides at least once during testing.

Consider the transition $t = (s,e,q)$, where $s$ is the original state, $e$ is the event label that triggers $t$ and $q$ is the destinity state. Previously, we computed that $s$ has coverage path $p$ such that $p \in C$ and $p$ is a sequence of label. The test case $TC$ to $t$ would be the concatenation of the event label $e$ to the end of $p$ expecting to get to state $q$. The process is repeated to every transition in the statechart.

@@@@@ADICIONAR EXEMPLO!!!!!

\subsection{Test case for complex statecharts: hierarchy}

In this section, the test cases generated will be obtained from statecharts that have hierarchy: a state may contain many substates and so on. We do not limit the level of nested hierarchy for the automatic generation.

One way to deal with hierarchy is to eliminate it from the model by flattening the statechart as shown in \ref{flattening}. The statechart would become an automaton and the thecniques for simple statecharts explained in the previous section could be used to generate test cases. But, the approach taken in this project, as in \cite{bogdanov}, was to keep the structure of the statechart and create the test cases incrementally.

Similarly to the previous simpler case, for statecharts with hierarchy we still need to cover all states by constructing the set $C$ and then test all transitions in the model. The construction of $C$, however, needs to take into consideration substates to cover them as well. It is important to note that we considered only statecharts that do not have transitions between different hierarchy levels.

When we get a state, we should check if it contains substates. If it does, we can compute their coverage paths going deeper in the hierarchy level and later concatenate the coverage path of the super state to the begining of each coverage path of the substates. Then, the coverage path of the super state should be removed from $C$ and the paths to the substates will be kept in $C$ instead.

The algorithm to construct $C$ needs some changes then:

@@@@@ALGORITMO PARA NOVA CONSTRUCAO DO C 

Find an example below:

@@@@@ COLOCAR EXEMPLO COM HIERARQUIA

After the set $C$ is complete, we need to in fact create the test cases based on every transition that leaves each state. In states that do not have substates, the process is the one presented in the previuos section. If a state contains substates, however, we must transfer the origin of every transition that leaves it to each one of its substates. Consider the case that a state $s$ has a transition $t = (s,e,q)$ and contains substates $s_1, s_2$ and $s_3$. When creating the test case to $t$, we will actually consider three new transitions: $t_1 = (s_1,e,q), t_2 = (s_2,e,q)$ and $t_3 = (s_3,e,q)$. 

\subsection{Test case for complex statecharts: orthogonality}

Now we shall consider statecharts that possess orthogonality, in other words, states in concurrent regions.

One fisrt method to generate test cases dealing with orthogonality is to eliminate it by flattening the statechart as explained in \ref{flattening}. The elimation of orthogonality would be done with the cartesian product of all states and transitions causing an explosion in the number of result states and transitions \cite{bogdanov}.

There are some possible refinements to stablish in order to generate fewer test cases and stil get all states covered and all transitions tested. The one used for this project was the following:

\begin{itemize}

\item \textbf{Strong concurrency}

This refinement allows us to test concurrent components separately. Transitions from each concurrent region are triggered one-by-one in different steps.
The \textit{State Cover} set $C$ for this refinement is smaller than in the weak concurrency or in the state multiplication.
\end{itemize}

We first compute the covage paths for each concurrent region separately. Then, similarly to the case with hierarchy, we combine these paths with the coverage path of the state that contains the concurrent regions. After obtaining the coverage path for all states, set $C$ is complete. Find the algorithm below:

@@@@@ADICIONAR PSEUDO-CODIGO

Next, we again need to generate the test cases for each transition of the model. This process is the same as the one described in the case with hierarcy since concurrent states are inside a super state. Find example below:

@@@@@ADICIONAR EXEMPLO

