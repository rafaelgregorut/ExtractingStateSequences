\section{Generation of properties for specific events}
\label{sec-genpropspecific}

Due to the fact the only the patterns returned by the sequential mining are considered to derive the property specifications, only the events that often appear in the test cases are going to be selected to create properties. Rare events are discarded when the minimum support is too high. An immediate solution would be to set the minimum support as a low value, but that would cause too many patterns to be selected and many irrelevant properties may be specified making the model checking process more costy in time and resources.

Taking these aspects into consideration, we propose a solution that gives the users the option to input specific events to which they want properties to be specified. This approach allows rare events to be handled properly and, since the user is able to check which properties we were automatically generated with mining, becomes a general solution to formally specify event-based requirements.

For the specific event $l$ passed by the user, we initially select the test cases that contain $l$ to constrcut our sequence database. Secondly, we run the $PrefixSpan$ provided by $SPMF$ with minimum support of $0$, which will output all possible sequence combination present in the database that contain the event $l$. Then, we are able to construct response property specifications for $l$.

As an example, consider the \textit{setRegularUser} event, which is not present in the properties in table \ref{propertiesTrocaPlano} generated with minimum support of $70\%$. Suppose a user wishes to obtain reponse properties with this event and inputs it in our implementation.

We, then, construct a new sequence database that has only sequences that contain the event \textit{setRegularUser}. The next step, is to run $PrefixSpan$ with minimum support of 0. With that input value, the algorithm will generate all possible combinations that can be derive from the specific database. To ilustrate this, we provide the specific database in table \ref{specificDatabase} and some of the possible combinations in table \ref{combinations}.

\begin{table}[]
\begin{center}
\begin{tabular}{|p{15cm}|}

\hline

doLogin -1 searchLineNumber -1 searchEmployee -1 setRegularUser -1 -2 \\ \hline
doLogin -1 searchLineNumber -1 searchEmployee -1 setRegularUser -1 searchContract -1 -2\\ \hline
doLogin -1 searchLineNumber -1 searchEmployee -1 setRegularUser -1 searchContract -1 setCommittedUser -1 -2\\ \hline
doLogin -1 searchLineNumber -1 searchEmployee -1 setRegularUser -1 searchContract -1 setCommittedUser -1 emptyCart -1 -2\\ \hline
doLogin -1 searchLineNumber -1 searchEmployee -1 setRegularUser -1 searchContract -1 setNotCommittedUser -1 -2\\ \hline
doLogin -1 searchLineNumber -1 searchEmployee -1 setRegularUser -1 searchContract -1 setNotCommittedUser -1 proceedCheckout -1 -2\\

\hline
\end{tabular}
\end{center}
\caption{Specific database for event \textit{setRegularUser}.}
\label{specificDatabase}
\end{table}

\begin{table}[]
\begin{center}
\begin{tabular}{|p{15cm}|}

\hline

setRegularUser \\ \hline
setRegularUser, searchContract\\ \hline
setRegularUser, searchContract, setNotCommittedUser\\ \hline
setRegularUser, searchContract, setNotCommittedUser,proceedCheckout\\ \hline
setRegularUser, searchContract, emptyCart\\ \hline
doLogin, searchEmployee, setRegularUser\\ \hline
doLogin, searchEmployee, setRegularUser, searchContract\\ \hline
doLogin, searchEmployee, setRegularUser, searchContract, setNotCommittedUser\\ \hline
doLogin, searchEmployee, setRegularUser, searchContract, setNotCommittedUser, proceedCheckout\\

\hline
\end{tabular}
\end{center}
\caption{Some sequence combinations generated by $PrefixSpan$ for \textit{setRegularUser}.}
\label{combinations}
\end{table}

Finally, for each sequence combination returned, we can specify the related response property. The pseudocode is similar to the one shown in \ref{responseSpec} and goes as follows:

\begin{lstlisting}[mathescape]
//Method to write the specification of formal response properties
//It receives as argument a sequence combination and the specific event 

Set propertySet = new Set();

Set extractResponseProperties(Sequence combination, Event specific) {

	for (i = 0; i < pattern.length - 1; i++) {
		Event P = pattern.getEvent(i);
		Event S = pattern.getEvent(i+1);
		if (P == specific or S == specific) {
			Property responseProperty = $\Box$(P.getName() $\rightarrow$ $\Diamond$ S.getName());

			if (!propertySet.contains(responseProperty))
				propertySet.add(responseProperty);
		}
	}
	return propertySet;
}
\end{lstlisting}

Considering the whole set of combinations for \textit{setRegularUser}, the response properties below are automatically specified:

\begin{table}[h]
\begin{center}
\begin{tabular}{|p{7cm}|l|}

\hline

Informal description & Formal specification \\ \hline

setRegularUser responds to searchEmployee & $\Box (searchEmployee \rightarrow \Diamond setRegularUser)$ \\ \hline
searchContract responds to setRegularUser & $\Box (setRegularUser \rightarrow \Diamond searchContract)$ \\ \hline
setRegularUser responds to searchLineNumber & $\Box (searchLineNumber \rightarrow \Diamond setRegularUser)$ \\ \hline
setCommittedUser responds to setRegularUser & $\Box (setRegularUser \rightarrow \Diamond setCommittedUser)$ \\ \hline
setNotCommittedUser responds to setRegularUser & $\Box (setRegularUser \rightarrow \Diamond setNotCommittedUser)$ \\ \hline
setRegularUser responds to doLogin & $\Box (doLogin \rightarrow \Diamond setRegularUser)$ \\ \hline
emptyCart responds to setRegularUser & $\Box (setRegularUser \rightarrow \Diamond emptyCart)$\\ \hline
proceedCheckout responds to setRegularUser & $\Box (setRegularUser \rightarrow \Diamond proceedCheckout)$ \\

\hline
\end{tabular}
\end{center}
\caption{Response properties for event \textit{setRegularUser}.}
\label{specificProperties}
\end{table}

Moreover, we can summerize the extracted properties by combining them in a similar process as presented in section \ref{responseSpec}. There are properties in which some event responds to \textit{setRegularUser} and in others \textit{setRegularUser} responds to some event. Hence, we are left with the following two concise properties to use in the model checking verification:

\begin{itemize}

\item \textit{Informal description}: emptyCart, proceedCheckout, setCommittedUser, setNotCommittedUser and searchContract respond to setRegularUser

\textit{Formal specification}: $\Box(setRegularUser \rightarrow \Diamond(emptyCart \wedge proceedCheckout$

$ \wedge setCommittedUser \wedge setNotCommittedUser \wedge searchContract))$

\item \textit{Informal description}: setRegularUser responds to doLogin, searchLineNumber and searchEmployee

\textit{Formal specification}: $\Box ((doLogin \vee searchLineNumber \vee searchEmployee) \rightarrow $

$\Diamond(setRegularUser))$

\end{itemize}

\iffalse
\begin{table}[h]
\begin{center}
\begin{tabular}{|p{7cm}|p{10cm}|}

\hline

Informal description & Formal specification \\ \hline

emptyCart, proceedCheckout, setCommittedUser, setNotCommittedUser and searchContract respond to setRegularUser & $\Box (setRegularUser \rightarrow \Diamond (emptyCart \wedge proceedCheckout \wedge setCommittedUser \wedge setNotCommittedUser \wedge searchContract))$ \\ \hline
setRegularUser responds to doLogin, searchLineNumber and searchEmployee & $\Box ((doLogin \vee searchLineNumber \vee searchEmployee) \rightarrow \Diamond(setRegularUser))$ \\

\hline
\end{tabular}
\end{center}
\caption{Combined properties from \ref{specificProperties}}
\label{specificPropertiesCombined}
\end{table}
\fi
