%% ------------------------------------------------------------------------- %%
\section{Software testing}
\label{sec:tests}

Since code has been written, programs have been tested. Testing is one of the most important means of assessing the software quality and it typically consumes from 40\% up to 50\% of the software development effort \cite{Luo}. Therefore, it constitute an important area in software engineering.

Testing evolved from an activity related to debugging code to way of checking specification, design as well as implementation\cite{Luo}. It can be considered a process not only to detect bugs, but also to prevent them \cite{Beizer}.

\subsection{Testing goals}

In an organization, the goals of testing depends on the level of maturity of the team \cite{Ammann:08}. At a more naive approach, testing could be viewed as debugging code. A further step would be to consider testing as a process to make sure that a software does what it is required to do. But, in this case, if a team runs a test suite and every test case passes it, should the team consider that the software is correct? Are the test cases not enough? Do they guarantee the software quality? How does the team decide when to stop testing? 

At a different perspective, testing can be understood as a process of finding errors. Therefore a successful test case would be the one that indicated an error in the system \cite{Myers:12}. Altough discovering unexpected results and behaviours is a valid goal, it might put tester and developers in an adversarial relationship, which certainly damages the team interaction. 

Testing shows the presence, but not the absence of errors. Hence, realizing that when executing a software we are under some risk that may have unimportant or great consequences leads to another way to see the intention of the test process: to reduce the risk of using the program, an effort that should be performed by both testers and developers. 

Thus, testing can be seen as a mental discipline that helps all professionals in the software industry to increase quality \cite{Ammann:08}. The whole software development process could benefit from that thinking: design and specification would be more clear and precise and the implementation would have fewer errors and would be more easily validated, for example.


\subsection{The process of testing}

Since testing is a time consuming activity, the creation of test cases can be done during each stage of the development process, even though their execution will only be possible after some part of the code is implemented.

\subsubsection{V-Model}

\begin{figure}[htb]
\includegraphics[width=1.0\textwidth]{figuras/vModel}
\caption{\label{fig:vModel}The V-model}
\end{figure}

The V-model shown in Figure \ref{fig:vModel} associates each level of testing to a different phase in the development process. This model is typically viewed as an extension of the waterfall methodology, but it does not imply the waterfall approach, since the synthesis and analysis activities can be applied to any development process \cite{Ammann:08}. 

\begin{itemize}

\item Requirement analysis phase: Customer's needs are registered. \textbf{User acceptance tests (UAT)} are constructed to check whether the delivered system meets the customer's requirements.

\item System design phase: Technical team analyses the captured requirements, studies the possible implementations and documents a technical specification. \textbf{System tests} are designed at this stage assuming that each component works accordingly and checks for the system to work as a whole.

\item Architectural design phase: Specify interface relationships, dependencies, structure and behaviour of subsystems. \textbf{Integration tests} are developed, with the assumption that each module works correctly, in order to verify all interfaces and communication among subsystems.

\item Detailed design phase: A low-level design is done to divide the system in smaller pieces, each of them with the corresponding behaviour specified so that the programmer can code. \textbf{Module testing} is designed to check each module individually.

\item Implementation phase: Code is actually produced. \textbf{Unit tests} are designed to test if every smallest unit of code, such as a method, can work correctly when isolated.
 
\end{itemize}

\subsection{Functional and Structural tests}

Testing techniques can be divided into functional and structural categories.

\subsubsection{Functional technique (black box)}
\label{funcTests}

The software behaviour described in the specification is considered to create the test cases. It is necessary to study the behaviour, develop the corresponding test cases, submit the system to the test cases and analyse the results observed comparing them to what was expected according to the description in the specification\cite{introSoftTest}:

	\begin{itemize}
	\item \textbf{Equivalence classes partitioning}
	
	Input data are partitioned into valid and invalid classes according to the conditions specified. The test cases are created based on each class by selecting an element in each class as a representative of the whole class. Using this criterion, the test cases can be executed systematically according to the requirements.

	\item \textbf{Analysis of the boundary value}
	
	Similar to the previous criterion, but the selection of the representative is done based on the classes' boundary. For that reason, the conditions associated with the limit values are exercised more strictly.

	\end{itemize}

Since many specifications are written in a descriptive fashion, the test cases developed using the functional technique can be very informal and not rigorous enough, which makes it difficult to automate their execution and human intervention becomes necessary. However, this technique only requires that requirements, input and corresponding output are identified. Thus, it can be applied during several testing phases, such as integration and system testing.

\subsubsection{Structural technique (white box)}
\label{strucTest}

The structure of the code implementation is considered to create the test cases in this category. In this technique, the program is represented by an oriented flow control graph, in which each vertex corresponds to a block of code (a statement in the code for instance) and each edge corresponds to a transition between blocks. The criteria related to this technique are concerned with the coverage of the program graph, such as \cite{Ammann:08}:

	\begin{itemize}
	\item \textbf{Node coverage}

	Every reachable node in the graph must be exercised by the test set. Node coverage is implemented by many testing tools, most often in the form of statement coverage
	
	\item \textbf{Edge coverage}

	Every edge in the graph must be tested in the test set.
	\item \textbf{Complete path coverage}

	All paths in the graph must be tested by the test set. This criterion is infeasible if there are cycles in the graph due to the infinity number of paths.

	\item \textbf{Prime path coverage}

	A path is a prime path if it is a simple path and it does not appear as a proper sub-path of any other simple path. In this criterion, all prime paths should be tested.

	\item \textbf{Specified Path Coverage}

	A specific set $S$ of paths is given and the test set must exercise all paths in $S$. This situation might occur if the use case scenarios provided by the customer are converted to paths in the graph and the team wishes to test them. 
	\end{itemize}

Tests obtained via the structural technique contribute specially to code maintenance and increase the reliability of the implementation. But, they do not represent a way to validate the system against the customer's requirements, since the specified requirements are not considered in their design.

%\subsection{Formal methods and tests}

\iffalse

Testar é o processo de executar um programa com o objetivo de encontrar erros \citep{Myers:12}. Muitas vezes o processo de teste é visto erroneamente somente como um meio de garantir que um programa faz aquilo que deveria fazer. Entretanto, a atividade de testar uma aplicação deve ser encarada como uma forma de encontrar comportamentos e resultados inesperados. Sendo assim, pode-se dizer que um teste bem sucessido é aquele que encontra um defeito no sistema\citep{Myers:12}, embora tal terminologia seja comumente utilzada na indústria para referir-se a testes que não detectem nenhuma anomalia.

As técnicas de testes podem ser classificadas em duas categorias:

\begin{itemize}
\item Técnica funcional (caixa-preta)

Considera-se as funcionalidades descritas na especificação para a criação dos casos de teste. É necessário estudar os comportamentos e funcionalidades especificados, criar os casos de teste correspondentes, submeter o sistema aos casos criados e analisar os resultados comparando-os com a descrição da especificação. Alguns exemplos de critérios dessa técnica são\citep{introSoftTest}:

	\begin{itemize}
	\item Particionamento em classes de equivalência
	
	Os dados de entrada são particionados em classes válidas e inválidas de acordo com a condições presentes na especificação. Os casos de teste são criados com base em cada classe selecionando-se um elemento de cada classe como representante da classe toda. Com esse critério, os casos de teste podem ser executados de maneira sistemática de acordo com os requisitos.
	\item Análise do valor limite
	
	Semelhante ao critério antetior, porém a seleção do representante de cada classe é feita na fronteira entre as classes. Desse modo, as condições associadas a valores limites são exercitadas mais rigorosamente.
	\end{itemize}

Como a maioria das especificações é feita de modo descritivo, os casos de teste gerados pela técnica funcional podem ser informais e imprecisos, o que dificulta a automação de sua execução e torna necessária a intervenção humana. Entretanto, essa técnica exige somente que sejam identificados os requisitos, as entradas e saídas correspondentes, o que a torna praticável durante todas as fases de teste (unidade, integração e sistema).

\item Técnica Estrutural (caixa-branca)

Considera-se a estrutura da implementação do código para a criação dos casos de teste. Nessa técnica, o programa é representado por um grafo orientado de fluxo de controle, onde cada vértice corresponde a um bloco de código, um comando por exemplo, e cada arco corresponde à transição entre os blocos. São critérios dessa técnica:

	\begin{itemize}
	\item Todos-nós

	Exige que todos os vértices, ou seja, todos os comandos, sejam exercitados.
	
	\item Todos-arcos

	Exige que todos os arcos, ou seja, todas as mudanças de fluxo, sejam exercitados

	\item Todos-caminhos

	Exige que todos os caminhos possíveis do programa sejam exercitados
	\end{itemize}

Os testes derivados da técnica estrutural contribuem especialmente para a manutenção, depuração e aumento da confiabilidade da implementação do programa. Entretanto, eles não representam um meio de validar o sistema, pois não levam em consideração os requisitos especificados.
\end{itemize}

Portanto, percebe-se que as duas técnicas devem ser usadas de maneira complementar. Os testes funcionais colaboram para a validaçãos dos requisitos com base na especificação e os testes estruturais são relevantes para analisar a cobertura e confiabilidade do código escrito.
\fi
